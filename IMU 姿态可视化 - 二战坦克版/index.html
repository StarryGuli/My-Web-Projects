<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>IMU å§¿æ€å¯è§†åŒ– - æé€Ÿç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1e1e1e; color: #cfcfcf; font-family: 'Consolas', monospace; }

        /* ä¾§è¾¹æ  */
        #sidebar {
            position: absolute; left: 0; top: 0; width: 320px; height: 100vh;
            background-color: #252526; border-right: 1px solid #333;
            padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; gap: 12px; z-index: 10;
        }

        h2 { margin: 0; font-size: 18px; color: #fff; border-bottom: 2px solid #007acc; padding-bottom: 8px; }

        /* æ•°æ®é¢æ¿ */
        .data-panel { background-color: #1e1e1e; border: 1px solid #3e3e42; padding: 10px; font-size: 14px; border-radius: 4px;}
        .data-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .data-value { color: #4ec9b0; font-weight: bold; min-width: 60px; text-align: right; }

        /* æ§åˆ¶å¼€å…³åŒºåŸŸ */
        .control-panel { background-color: #2d2d30; padding: 10px; border-radius: 4px; border: 1px solid #3e3e42; }
        .checkbox-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px; font-size: 13px; cursor: pointer; }
        .checkbox-row:hover { color: #fff; }
        input[type="checkbox"] { cursor: pointer; transform: scale(1.2); }

        /* æŒ‰é’®ä¸è¾“å…¥ */
        button { width: 100%; background-color: #0e639c; color: white; border: none; padding: 8px; cursor: pointer; border-radius: 2px; font-size: 14px; }
        button:hover { background-color: #1177bb; }
        button.disconnect { background-color: #a1260d; }
        select { width: 100%; background: #3c3c3c; color: #fff; padding: 5px; border: 1px solid #555; }

        /* æ—¥å¿—åŒº - ä¼˜åŒ–æ€§èƒ½ */
        #log {
            flex-grow: 1; background: #000; border: 1px solid #333;
            padding: 5px; font-size: 11px; overflow-y: hidden; /* éšè—æ»šåŠ¨æ¡æå‡æ€§èƒ½ */
            white-space: pre-wrap; color: #ce9178; font-family: monospace;
            opacity: 0.8;
        }

        #canvas-container {
            position: absolute; left: 320px; top: 0; width: calc(100% - 320px); height: 100vh;
            background: radial-gradient(circle at center, #2d2d30 0%, #1e1e1e 100%);
        }
        
        #fps-counter { position: absolute; top: 5px; right: 5px; color: #555; font-size: 10px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="sidebar">
    <h2>CH340 IMU Vis</h2>
    
    <div>
        <label style="font-size:12px; color:#888;">æ³¢ç‰¹ç‡ (Baud Rate)</label>
        <select id="baudRate">
            <option value="9600">9600</option>
            <option value="115200" selected>115200</option>
            <option value="921600">921600</option>
        </select>
    </div>
    <button id="connectBtn">ğŸ”Œ è¿æ¥ä¸²å£</button>
    <div id="status" style="font-size:12px; color:#ffd700;">æœªè¿æ¥</div>

    <div class="control-panel">
        <div style="font-size:12px; color:#888; margin-bottom:5px;">è½´å‘æ ¡å‡† (Axis Invert)</div>
        <label class="checkbox-row">
            <span>åè½¬ Pitch (ä¿¯ä»°)</span>
            <input type="checkbox" id="inv-pitch">
        </label>
        <label class="checkbox-row">
            <span>åè½¬ Roll (æ¨ªæ»š)</span>
            <input type="checkbox" id="inv-roll">
        </label>
        <label class="checkbox-row">
            <span>åè½¬ Yaw (åèˆª)</span>
            <input type="checkbox" id="inv-yaw">
        </label>
    </div>

    <div class="data-panel">
        <div class="data-row"><span>Pitch:</span> <span id="val-pitch" class="data-value">0.00</span></div>
        <div class="data-row"><span>Roll:</span> <span id="val-roll" class="data-value">0.00</span></div>
        <div class="data-row"><span>Yaw:</span> <span id="val-yaw" class="data-value">0.00</span></div>
    </div>

    <div id="log">Waiting...</div>
</div>

<div id="canvas-container">
    <div id="fps-counter">FPS: 60</div>
</div>

<script>
    // ================= 1. å…¨å±€çŠ¶æ€ç®¡ç† =================
    const state = {
        raw: { p: 0, r: 0, y: 0 },   // ä¸²å£è¯»åˆ°çš„åŸå§‹å€¼
        target: { p: 0, r: 0, y: 0 },// ç»è¿‡åè½¬å¤„ç†çš„ç›®æ ‡å€¼
        current: { p: 0, r: 0, y: 0 },// å½“å‰åŠ¨ç”»æ˜¾ç¤ºçš„å¹³æ»‘å€¼
        logBuffer: [], // æ—¥å¿—ç¼“å­˜
        isConnected: false
    };

    // UI å…ƒç´ ç¼“å­˜
    const ui = {
        p: document.getElementById('val-pitch'),
        r: document.getElementById('val-roll'),
        y: document.getElementById('val-yaw'),
        log: document.getElementById('log'),
        invP: document.getElementById('inv-pitch'),
        invR: document.getElementById('inv-roll'),
        invY: document.getElementById('inv-yaw'),
        status: document.getElementById('status'),
        btn: document.getElementById('connectBtn')
    };

    // ================= 2. Three.js åœºæ™¯ (äºŒæˆ˜å¦å…‹) =================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(6, 5, 8);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1); // ä¼˜åŒ–é«˜åˆ†å±æ€§èƒ½
    container.appendChild(renderer.domElement);

    // ç¯å…‰
    scene.add(new THREE.AmbientLight(0x555555));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    // åœ°é¢ç½‘æ ¼
    scene.add(new THREE.GridHelper(30, 30, 0x444444, 0x222222));
    scene.add(new THREE.AxesHelper(1.5));

    // æ„å»ºå¦å…‹æ¨¡å‹
    const tankGroup = new THREE.Group();
    const matBody = new THREE.MeshLambertMaterial({ color: 0x556b2f }); // å†›ç»¿
    const matTrack = new THREE.MeshLambertMaterial({ color: 0x111111 });
    const matSteel = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.4 });

    // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºç›’å­
    function createBox(w, h, d, mat, x, y, z) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
        mesh.position.set(x, y, z);
        return mesh;
    }

    // è½¦ä½“
    tankGroup.add(createBox(2.2, 0.8, 3.6, matBody, 0, 0.6, 0));
    // ç‚®å¡”
    tankGroup.add(createBox(1.6, 0.7, 2.0, matBody, 0, 1.35, 0.2));
    // å±¥å¸¦
    tankGroup.add(createBox(0.6, 0.8, 3.8, matTrack, -1.3, 0.4, 0));
    tankGroup.add(createBox(0.6, 0.8, 3.8, matTrack, 1.3, 0.4, 0));
    // ç‚®ç®¡
    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 3.5, 12), matSteel);
    barrel.rotation.x = Math.PI / 2;
    barrel.position.set(0, 1.35, 2.0);
    tankGroup.add(barrel);
    
    scene.add(tankGroup);

    // ================= 3. åŠ¨ç”»ä¸æ¸²æŸ“å¾ªç¯ (æ ¸å¿ƒä¼˜åŒ–) =================
    const d2r = Math.PI / 180;
    
    function animate() {
        requestAnimationFrame(animate);

        // 1. è¯»å–å¼€å…³çŠ¶æ€å¹¶åº”ç”¨åˆ°ç›®æ ‡è§’åº¦
        const invP = ui.invP.checked ? -1 : 1;
        const invR = ui.invR.checked ? -1 : 1;
        const invY = ui.invY.checked ? -1 : 1;

        // 2. ç®€å•çš„çº¿æ€§æ’å€¼ (Lerp) ä½¿åŠ¨ä½œå¹³æ»‘ï¼Œé¿å…æ•°æ®æŠ–åŠ¨
        // 0.1 æ˜¯å¹³æ»‘ç³»æ•°ï¼Œè¶Šå°è¶Šå¹³æ»‘ä½†å»¶è¿Ÿè¶Šé«˜ï¼Œ0.2 å“åº”å¿«
        state.current.p += (state.raw.p * invP - state.current.p) * 0.15;
        state.current.r += (state.raw.r * invR - state.current.r) * 0.15;
        state.current.y += (state.raw.y * invY - state.current.y) * 0.15;

        // 3. åº”ç”¨æ—‹è½¬ (æ³¨æ„ ThreeJS çš„æ—‹è½¬é¡ºåºï¼Œé€šå¸¸ ZXY æˆ– XYZ)
        // æ˜ å°„ï¼šPitch->X, Yaw->Y, Roll->Z (æ ¹æ®ä½ çš„æˆªå›¾é€šå¸¸æ˜¯è¿™æ ·ï¼Œå¦‚æœä¸å¯¹åº”å¯ä»¥æ”¹è¿™é‡Œ)
        tankGroup.rotation.x = state.current.p * d2r; 
        tankGroup.rotation.y = -state.current.y * d2r; // Yaw é€šå¸¸éœ€è¦å–åé€‚é…å±å¹•åæ ‡
        tankGroup.rotation.z = state.current.r * d2r; 

        renderer.render(scene, camera);
    }
    animate();

    // ================= 4. UI æ›´æ–°å¾ªç¯ (èŠ‚æµä¼˜åŒ–) =================
    // æ¯ 100ms åˆ·æ–°ä¸€æ¬¡æ–‡å­—æ˜¾ç¤ºï¼Œé¿å…å¡é¡¿ï¼Œå®Œå…¨ä¸å½±å“ 3D çš„ 60FPS
    setInterval(() => {
        if (!state.isConnected) return;

        // æ›´æ–°æ•°å­—
        ui.p.textContent = state.raw.p.toFixed(2);
        ui.r.textContent = state.raw.r.toFixed(2);
        ui.y.textContent = state.raw.y.toFixed(2);

        // æ›´æ–°æ—¥å¿— (åªæ˜¾ç¤ºæœ€åä¸€è¡Œ)
        if (state.logBuffer.length > 0) {
            ui.log.textContent = state.logBuffer[state.logBuffer.length - 1] + "\n...";
            state.logBuffer = []; // æ¸…ç©ºç¼“å­˜
        }
    }, 100); 


    // ================= 5. ä¸²å£é€šä¿¡é€»è¾‘ =================
    let port, reader;
    
    ui.btn.addEventListener('click', async () => {
        if (state.isConnected) {
            await reader.cancel();
            await port.close();
            state.isConnected = false;
            ui.btn.textContent = "ğŸ”Œ è¿æ¥ä¸²å£";
            ui.btn.classList.remove('disconnect');
            ui.status.textContent = "æœªè¿æ¥";
            ui.status.style.color = "#ffd700";
            return;
        }

        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: parseInt(document.getElementById('baudRate').value) });
            
            state.isConnected = true;
            ui.btn.textContent = "âŒ æ–­å¼€è¿æ¥";
            ui.btn.classList.add('disconnect');
            ui.status.textContent = "æ¥æ”¶æ•°æ®ä¸­...";
            ui.status.style.color = "#4ec9b0";

            readSerialLoop();
        } catch (err) {
            alert("è¿æ¥é”™è¯¯: " + err);
        }
    });

    async function readSerialLoop() {
        const decoder = new TextDecoderStream();
        const readableStreamClosed = port.readable.pipeTo(decoder.writable);
        reader = decoder.readable.getReader();
        
        let buffer = "";
        const regex = /Pitch:([-\d.]+)\s+Roll:([-\d.]+)\s+Yaw:([-\d.]+)/;

        try {
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                
                buffer += value;
                
                // å¿«é€Ÿå¤„ç†åˆ†è¡Œ
                const lines = buffer.split('\n');
                buffer = lines.pop(); // ä¿ç•™æœªå®Œæˆçš„æœ«å°¾

                for (const line of lines) {
                    const cleanLine = line.trim();
                    if (cleanLine.length < 5) continue;

                    // è§£ææ•°æ® (è¿™é‡Œåªæ›´æ–°æ•°æ®çŠ¶æ€ï¼Œä¸æ“ä½œ DOM)
                    const match = cleanLine.match(regex);
                    if (match) {
                        state.raw.p = parseFloat(match[1]);
                        state.raw.r = parseFloat(match[2]);
                        state.raw.y = parseFloat(match[3]);
                        
                        // å°†åŸå§‹å­—ç¬¦ä¸²æ¨å…¥æ˜¾ç¤ºç¼“å­˜
                        state.logBuffer.push(cleanLine);
                    }
                }
            }
        } catch (error) {
            console.error(error);
        } finally {
            reader.releaseLock();
        }
    }

    // çª—å£è‡ªé€‚åº”
    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
</body>
</html>