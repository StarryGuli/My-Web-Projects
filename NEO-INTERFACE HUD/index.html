<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>NEO-INTERFACE // CYBER HUD ULTIMATE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            background-color: #020205; /* 深空黑背景 */
            overflow: hidden;
            font-family: 'Orbitron', sans-serif; /* 如果有条件可以引入科幻字体 */
        }
        #container { position: relative; width: 100vw; height: 100vh; }
        /* 隐藏原始视频 */
        .input_video { display: none; }
        /* 3D场景层 */
        #three-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none;
        }
        /* 2D HUD层 */
        #hud-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }
        /* 界面UI文字 */
        .ui-overlay {
            position: absolute; z-index: 20; padding: 20px; color: #0ff; pointer-events: none;
        }
        h1 { margin: 0; text-shadow: 0 0 10px #0ff; letter-spacing: 3px; }
        .status-panel {
            margin-top: 20px; border-left: 3px solid #f0f; padding-left: 10px;
            background: linear-gradient(90deg, rgba(255,0,255,0.1), transparent);
        }
        #gesture-status { font-weight: bold; color: #ff0; text-shadow: 0 0 5px #ff0;}
    </style>
</head>
<body>
    <div id="container">
        <div class="ui-overlay">
            <h1>NEO::SYSTEM // ONLINE</h1>
            <div class="status-panel">
                <p>生物识别: <span id="bio-status">扫描中...</span></p>
                <p>指令输入: <span id="gesture-status">等待指令</span></p>
            </div>
        </div>
        
        <video class="input_video"></video>
        <canvas id="three-canvas"></canvas>
        <canvas id="hud-canvas"></canvas>
    </div>

<script>
    // ===========================
    // 1. 初始化设置 & 全局变量
    // ===========================
    const videoElement = document.getElementsByClassName('input_video')[0];
    const hudCanvas = document.getElementById('hud-canvas');
    const hudCtx = hudCanvas.getContext('2d');
    const threeCanvas = document.getElementById('three-canvas');
    const bioStatus = document.getElementById('bio-status');
    const gestureStatus = document.getElementById('gesture-status');

    let width = window.innerWidth;
    let height = window.innerHeight;

    hudCanvas.width = width; hudCanvas.height = height;
    threeCanvas.width = width; threeCanvas.height = height;

    // ===========================
    // 2. Three.js 场景搭建 (3D特效)
    // ===========================
    const scene = new THREE.Scene();
    // 使用正交相机，更容易对齐2D视频画面
    const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
    camera.position.z = 500;
    // 镜像翻转相机X轴，使操作符合直觉
    camera.scale.x = -1;

    const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
    renderer.setSize(width, height);

    // --- 创建手部 3D 对象池 ---
    const handJoints = []; // 存放21个关节的球体
    const handBones = [];  // 存放连接关节的线条
    const jointMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
    const boneMaterial = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 2 });

    // 初始化足够多的球体和线条 (为两只手准备)
    for (let i = 0; i < 42; i++) {
        const geometry = new THREE.SphereGeometry(i % 21 === 8 ? 8 : 4, 16, 16); // 食指指尖大一点
        const sphere = new THREE.Mesh(geometry, jointMaterial.clone());
        sphere.visible = false; // 初始不可见
        scene.add(sphere);
        handJoints.push(sphere);
    }
    // 简化的连接关系 (仅作为示例)
    const connections = [[0,1],[1,2],[2,3],[3,4], [0,5],[5,6],[6,7],[7,8], [5,9],[9,10],[10,11],[11,12]];
    for(let i=0; i < connections.length * 2; i++) {
        const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,10,0)]);
        const line = new THREE.Line(geometry, boneMaterial.clone());
        line.visible = false;
        scene.add(line);
        handBones.push(line);
    }

    // ===========================
    // 3. MediaPipe Holistic 集成
    // ===========================
    const holistic = new Holistic({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
    }});

    holistic.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    holistic.onResults(onResults);

    const cameraFeed = new Camera(videoElement, {
        onFrame: async () => { await holistic.send({image: videoElement}); },
        width: 1280, height: 720
    });
    cameraFeed.start();

    // ===========================
    // 4. 核心循环与渲染逻辑 (魔法发生地)
    // ===========================
    function onResults(results) {
        // --- A. 清理画布 ---
        hudCtx.clearRect(0, 0, width, height);
        
        let faceDetected = false;
        let handsDetected = 0;

        // 重置所有3D对象可见性
        handJoints.forEach(j => j.visible = false);
        handBones.forEach(b => b.visible = false);

        // --- B. 面部处理 (2D HUD) ---
        if (results.faceLandmarks) {
            faceDetected = true;
            // 绘制赛博朋克风格的面部网格
            drawFaceCyberMask(hudCtx, results.faceLandmarks);
        }

        // --- C. 手部处理 (3D Three.js & 交互逻辑) ---
        
        // 处理左手
        if (results.leftHandLandmarks) {
            handsDetected++;
            update3DHand(results.leftHandLandmarks, 0); // 使用前21个球体
            checkPinchGesture(results.leftHandLandmarks, "Left");
        }
        // 处理右手
        if (results.rightHandLandmarks) {
            handsDetected++;
            update3DHand(results.rightHandLandmarks, 21); // 使用后21个球体
            checkPinchGesture(results.rightHandLandmarks, "Right");
        }

        // --- D. 更新状态面板 ---
        updateStatusPanel(faceDetected, handsDetected);

        // --- E. 渲染 Three.js 场景 ---
        renderer.render(scene, camera);
    }

    // 辅助函数：将 MediaPipe 归一化坐标转换为 Three.js 世界坐标
    function mapCoordTo3D(landmark) {
        // MediaPipe: x(0~1 左到右), y(0~1 上到下)
        // Three.js Orthographic: x(-w/2 ~ w/2), y(h/2 ~ -h/2)
        const x = (landmark.x - 0.5) * width;
        const y = -(landmark.y - 0.5) * height; // Y轴取反
        // Z坐标用于深度感，稍微放大一点
        const z = landmark.z * -300; 
        return new THREE.Vector3(x, y, z);
    }

    // 更新 3D 手部模型
    function update3DHand(landmarks, offsetIndex) {
        // 更新关节位置
        for (let i = 0; i < landmarks.length; i++) {
            const joint = handJoints[offsetIndex + i];
            const pos = mapCoordTo3D(landmarks[i]);
            joint.position.copy(pos);
            joint.visible = true;

            // 特效：指尖变色
            if ([4,8,12,16,20].includes(i)) {
                 joint.material.color.setHex(0xff00ff); // 洋红指尖
            } else {
                 joint.material.color.setHex(0x00ffff); // 青色关节
            }
        }
        // 更新骨骼连线 (简单示例)
        for (let i = 0; i < connections.length; i++) {
            const bone = handBones[(offsetIndex/21 * connections.length) + i];
            const start = handJoints[offsetIndex + connections[i][0]].position;
            const end = handJoints[offsetIndex + connections[i][1]].position;
            const positions = bone.geometry.attributes.position.array;
            positions[0] = start.x; positions[1] = start.y; positions[2] = start.z;
            positions[3] = end.x; positions[4] = end.y; positions[5] = end.z;
            bone.geometry.attributes.position.needsUpdate = true;
            bone.visible = true;
        }
    }

    // ===========================
    // 5. 交互逻辑 (捏合手势)
    // ===========================
    function checkPinchGesture(landmarks, handName) {
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        // 计算欧几里得距离
        const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

        // 阈值判断 (根据实际体验调整)
        if (distance < 0.04) {
            gestureStatus.innerText = `${handName.toUpperCase()} HAND :: PINCH ACTIVATED`;
            gestureStatus.style.color = "#f00"; // 触发时变红
            gestureStatus.style.textShadow = "0 0 15px #f00";
            
            // 【炫酷点】在这里触发音效或网页操作
            // new Audio('click_sound.mp3').play(); 
        } else {
            gestureStatus.innerText = "等待指令";
            gestureStatus.style.color = "#ff0";
            gestureStatus.style.textShadow = "0 0 5px #ff0";
        }
    }

    // ===========================
    // 6. 2D HUD 绘制特效
    // ===========================
    function drawFaceCyberMask(ctx, landmarks) {
        hudCtx.save();
        hudCtx.strokeStyle = "rgba(0, 255, 255, 0.4)";
        hudCtx.lineWidth = 1;
        
        // 简单绘制眼睛周围和脸部轮廓的连接线 (示例索引)
        const cyberIndices = [
            [33, 133], [133, 155], [155, 33], // 左眼圈
            [362, 263], [263, 382], [382, 362], // 右眼圈
            [10, 338], [338, 297], [297, 332], [332, 284], // 右脸颊轮廓
            [10, 109], [109, 67], [67, 103], [103, 54] // 左脸颊轮廓
        ];
        
        ctx.beginPath();
        for(const pair of cyberIndices) {
             const p1 = landmarks[pair[0]];
             const p2 = landmarks[pair[1]];
             ctx.moveTo(p1.x * width, p1.y * height);
             ctx.lineTo(p2.x * width, p2.y * height);
        }
        ctx.stroke();

        // 在鼻尖画一个扫描点 (索引1)
        const nose = landmarks[1];
        ctx.fillStyle = "#f0f";
        ctx.beginPath();
        ctx.arc(nose.x * width, nose.y * height, 5, 0, 2 * Math.PI);
        ctx.fill();
        hudCtx.restore();
    }

    function updateStatusPanel(face, hands) {
        if (face && hands > 0) {
             bioStatus.innerHTML = `神经连接稳定 [ 面部锁定 | 手部单元: ${hands} ]`;
             bioStatus.style.color = "#0f0";
        } else if (face) {
             bioStatus.innerHTML = `面部已识别。等待手部输入...`;
             bioStatus.style.color = "#0ff";
        } else {
             bioStatus.innerHTML = `正在扫描...`;
             bioStatus.style.color = "#f00";
        }
    }

    // 窗口大小调整适应
    window.addEventListener('resize', () => {
        width = window.innerWidth;
        height = window.innerHeight;
        hudCanvas.width = width; hudCanvas.height = height;
        threeCanvas.width = width; threeCanvas.height = height;
        renderer.setSize(width, height);
        camera.left = width / -2; camera.right = width / 2;
        camera.top = height / 2; camera.bottom = height / -2;
        camera.updateProjectionMatrix();
    });
</script>
</body>
</html>